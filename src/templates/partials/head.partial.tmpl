{{define "head"}}
<head>
   <title>Moody App</title>
   <meta name="viewport" content="width=device-width, initial-scale=1.0" />
   <meta name="description" content="Moody - How are you feeling today?" />
   <meta name="author" content="Immanuel Garcia" />
   <meta name="keywords" content="Moody, mental wellness, playlist generator" />
   <meta name="theme-color" content="#ffffff" />
   <meta name="apple-mobile-web-app-capable" content="yes" />

   <!-- Tailwind CSS -->
   <link rel="stylesheet" href="/static/style.css" />

   <!-- franken/ui -->
   <script
	  src="https://cdn.jsdelivr.net/npm/franken-ui@2.0.0/dist/js/core.iife.js"
	  type="module"
   ></script>
   <script
	  src="https://cdn.jsdelivr.net/npm/franken-ui@2.0.0/dist/js/icon.iife.js"
	  type="module"
   ></script>

   <!-- unpkg/lucide - Lucide Icons -->
   <!-- Production version -->
   <script src="https://unpkg.com/lucide@latest"></script>

   <!-- Custom Elements -->
   <script src="/static/components/index.js" type="module"></script>

   <!-- WebAssembly -->
   <script src="/static/wasm/bundle/wasm_exec.js"></script>
   <script>
	  const go = new Go();
	  WebAssembly.instantiateStreaming(
		 fetch("/static/wasm/bundle/main.wasm"),
		 go.importObject,
	  ).then((result) => {
		 go.run(result.instance);
		 go_setpath("{{ .Data.Path }}"); // Should be replaced with the actual path after execution
	  });
   </script>

   <!-- Experimental: Using Popstate API for SPA navigation -->
   <script type="module">
	  window.addEventListener("popstate", async () => {
		 const route = location.pathname;

		 // Handle the new route in your frontend
		 console.log("Route changed to:", route);

		 // Fetch content from the Go backend (can be an API call or full-page fetch)
		 try {
			const response = await fetch(route);
			if (response.ok) {
			   const htmlContent = await response.text();
			   // Create a temporary DOM element to parse the HTML response
			   const parser = new DOMParser();
			   const doc = parser.parseFromString(htmlContent, "text/html");

			   // Extract the content from the new response's #content element
			   const newContent = doc.getElementById("content");
			   // If the #content element exists in the new HTML, update the current #content
			   if (newContent) {
				  // Update the #content on the current page
				  const contentContainer = document.getElementById("content");
				  contentContainer.innerHTML = newContent.innerHTML;

				  // Re-run any <script> tags within the new content
				  const scripts = newContent.querySelectorAll("script");
				  scripts.forEach((script) => {
					 // Create a new script element and execute it
					 const newScript = document.createElement("script");
					 newScript.text = script.textContent;
					 document.body.appendChild(newScript);
					 document.body.removeChild(newScript); // Optionally remove after execution
				  });
			   } else {
				  console.error("No #content element in the response.");
			   }
			} else {
			   console.error("Failed to fetch the route:", response.statusText);
			}
		 } catch (error) {
			console.error("Error fetching route:", error);
		 }
	  });
   </script>
</head>
{{end}}
